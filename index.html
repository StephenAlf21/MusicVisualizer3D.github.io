<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Music Visualizer with Playlist & Info Menu</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #111827; 
            --bg-secondary: #1f2937; 
            --bg-tertiary: #374151; 
            --bg-quaternary: #4b5563; 
            --bg-ui-container: rgba(0, 0, 0, 0.3);
            --bg-content-section: rgba(31, 41, 55, 0.7); 
            --bg-message-box: rgba(31, 41, 55, 0.9); 
            --bg-playlist: #1f2937; 
            --bg-playlist-item-hover: #374151;
            --bg-playlist-item-active: #4b5563;
            --bg-info-sidebar: #161e2b;
            --text-primary: #f3f4f6; 
            --text-secondary: #d1d5db; 
            --text-tertiary: #9ca3af; 
            --text-link: #60a5fa; 
            --text-link-hover: #93c5fd; 
            --border-primary: #4b5563; 
            --border-secondary: #374151; 
            --border-playlist: #374151;
            --border-info-sidebar: #374151;
            --slider-track: #4b5563; 
            --slider-thumb-volume: #10b981; 
            --slider-thumb-seek: #3b82f6; 
            --button-play-bg: #10b981; 
            --button-play-hover: #059669; 
            --button-play-border: #059669; 
            --button-pause-bg: #ef4444; 
            --button-pause-hover: #dc2626; 
            --button-pause-border: #dc2626; 
            --button-load-bg: #6b7280; 
            --button-load-hover: #4b5563; 
            --button-load-border: #4b5563; 
            --button-choose-bg: #2563eb; 
            --button-choose-hover: #1d4ed8; 
            --button-choose-border: #1d4ed8; 
            --button-skip-bg: #4b5563; 
            --button-skip-hover: #6b7280; 
            --button-skip-border: #374151; 
            --button-skip-disabled-bg: #374151; 
            --button-skip-disabled-text: #9ca3af; 
            --button-playlist-action-bg: #374151;
            --button-playlist-action-hover: #4b5563;
            --button-playlist-remove-bg: #ef4444;
            --button-playlist-remove-hover: #dc2626;
            --button-nav-bg: var(--bg-secondary);
            --button-nav-hover: #374151; 
            --button-nav-active-bg: #4b5563; 
            --theme-toggle-icon: "‚òÄÔ∏è"; 
            --theme-toggle-bg: #4b5563;
            --theme-toggle-hover: #6b7280;
        }

        .light-mode {
            --bg-primary: #f9fafb; 
            --bg-secondary: #f3f4f6; 
            --bg-tertiary: #e5e7eb; 
            --bg-quaternary: #d1d5db; 
            --bg-ui-container: rgba(255, 255, 255, 0.4);
            --bg-content-section: rgba(229, 231, 235, 0.8); 
            --bg-message-box: rgba(229, 231, 235, 0.9); 
            --bg-playlist: #f3f4f6;
            --bg-playlist-item-hover: #e5e7eb;
            --bg-playlist-item-active: #d1d5db;
            --bg-info-sidebar: #eef2f9;
            --text-primary: #1f2937; 
            --text-secondary: #374151; 
            --text-tertiary: #6b7280; 
            --text-link: #2563eb; 
            --text-link-hover: #3b82f6; 
            --border-primary: #d1d5db; 
            --border-secondary: #e5e7eb; 
            --border-playlist: #e5e7eb;
            --border-info-sidebar: #d1d5db;
            --slider-track: #d1d5db; 
            --slider-thumb-volume: #10b981; 
            --slider-thumb-seek: #3b82f6; 
            --button-play-bg: #10b981; 
            --button-play-hover: #059669; 
            --button-play-border: #059669; 
            --button-pause-bg: #ef4444; 
            --button-pause-hover: #dc2626; 
            --button-pause-border: #dc2626; 
            --button-load-bg: #9ca3af; 
            --button-load-hover: #6b7280; 
            --button-load-border: #6b7280; 
            --button-choose-bg: #2563eb; 
            --button-choose-hover: #1d4ed8; 
            --button-choose-border: #1d4ed8; 
            --button-skip-bg: #d1d5db; 
            --button-skip-hover: #9ca3af; 
            --button-skip-border: #e5e7eb; 
            --button-skip-disabled-bg: #e5e7eb; 
            --button-skip-disabled-text: #6b7280; 
            --button-playlist-action-bg: #e5e7eb;
            --button-playlist-action-hover: #d1d5db;
            --button-playlist-remove-bg: #ef4444;
            --button-playlist-remove-hover: #dc2626;
            --button-nav-bg: var(--bg-secondary);
            --button-nav-hover: #e5e7eb; 
            --button-nav-active-bg: #d1d5db; 
            --theme-toggle-icon: "üåô"; 
            --theme-toggle-bg: #d1d5db;
            --theme-toggle-hover: #9ca3af;
        }

        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            transition: background-color 0.3s ease, color 0.3s ease; 
            overflow: hidden; 
        }
        body.dynamic-bg-transition {
             transition: background-color 0.8s ease, color 0.3s ease !important; 
        }

        #page-container {
            flex-grow: 1;
            position: relative; 
            overflow: hidden; 
            height: calc(100vh - 50px); 
            display: flex;
        }
        
        #info-sidebar {
            width: 320px; 
            background-color: var(--bg-info-sidebar);
            border-right: 1px solid var(--border-info-sidebar);
            position: fixed; 
            left: 0;
            top: 50px; 
            bottom: 0;
            z-index: 100; 
            transform: translateX(-100%);
            transition: transform 0.3s ease-in-out;
            overflow-y: auto;
            padding: 1.5rem;
            box-sizing: border-box;
        }
        #info-sidebar.open {
            transform: translateX(0);
        }
        #info-sidebar .content-section {
            background-color: transparent; 
            box-shadow: none;
            padding: 0 0 1.5rem 0; 
        }
         #info-sidebar .content-section:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
        }
        #info-sidebar h2 {
            font-size: 1.25rem; 
            margin-bottom: 0.75rem;
        }

        #visualizer-page {
             display: flex; 
             flex-grow: 1; 
             height: 100%;
             padding: 0; 
             overflow: hidden; 
        }
        
        #main-content-area {
            flex-grow: 1; 
            position: relative; 
            height: 100%;
            overflow: hidden; 
        }

        #visualizer-canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%; 
            z-index: 0; 
        }

        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            z-index: 10; 
            background-color: var(--bg-ui-container);
            backdrop-filter: blur(4px);
            padding: 1rem;
            box-sizing: border-box;
            transition: background-color 0.3s ease;
        }
        
        #playlist-sidebar {
            width: 300px;
            flex-shrink: 0; 
            background-color: var(--bg-playlist);
            color: var(--text-primary);
            padding: 1rem;
            box-sizing: border-box;
            height: 100%; 
            overflow-y: auto; 
            border-left: 1px solid var(--border-playlist);
            transition: background-color 0.3s ease, border-color 0.3s ease, transform 0.3s ease-in-out;
            display: flex;
            flex-direction: column;
        }
        #playlist-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-primary);
        }
        #playlist-header h3 {
            font-size: 1.125rem; 
            font-weight: 600; 
            margin-bottom: 0;
        }
        #clear-playlist-button {
            background-color: var(--button-playlist-remove-bg);
            color: white;
            border: none;
            padding: 0.3rem 0.6rem;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        #clear-playlist-button:hover {
            background-color: var(--button-playlist-remove-hover);
        }
        #clear-playlist-button:disabled {
            background-color: var(--bg-tertiary);
            color: var(--text-tertiary);
            cursor: not-allowed;
            opacity: 0.7;
        }

        #playlist-items-container {
            flex-grow: 1;
            overflow-y: auto;
        }

        .playlist-item {
            display: flex;
            align-items: center;
            padding: 0.5rem 0.75rem;
            border-radius: 0.375rem; 
            margin-bottom: 0.25rem;
            cursor: grab;
            transition: background-color 0.2s ease;
        }
        .playlist-item:hover {
            background-color: var(--bg-playlist-item-hover);
        }
        .playlist-item.active-track {
            background-color: var(--bg-playlist-item-active);
            font-weight: 500; 
        }
        .playlist-item-name {
            flex-grow: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-right: 0.5rem;
            font-size: 0.875rem; 
        }
        .playlist-item-controls {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }
        .playlist-item-button {
            background-color: var(--button-playlist-action-bg);
            color: var(--text-primary);
            border: 1px solid var(--border-secondary);
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem; 
            cursor: pointer;
            font-size: 0.75rem; 
            transition: background-color 0.2s ease;
            min-width: 50px; 
            text-align: center;
        }
        .playlist-item-button:hover {
            background-color: var(--button-playlist-action-hover);
        }
        .playlist-item-remove-button {
            background-color: transparent; 
            color: var(--text-tertiary);
            border: none;
            padding: 0.25rem; 
            border-radius: 0.25rem;
            cursor: pointer;
            font-size: 1rem;
            line-height: 1;
            transition: color 0.2s ease, background-color 0.2s ease;
        }
        .playlist-item-remove-button:hover {
            color: var(--button-playlist-remove-bg);
        }

        #empty-playlist-message {
            text-align: center;
            color: var(--text-tertiary);
            margin-top: 2rem;
            font-style: italic;
        }

        .playlist-item.dragging {
            opacity: 0.5;
            background-color: var(--bg-quaternary);
        }
        .drop-target-above {
            border-top: 2px dashed var(--text-link);
            margin-top: -2px;
        }
        .drop-target-below {
            border-bottom: 2px dashed var(--text-link);
            margin-bottom: -2px;
        }


        #timeline-row { width: 100%; }

        #message-box {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            display: none;
            background-color: var(--bg-message-box);
            color: var(--text-primary);
            font-weight: bold;
            text-align: center;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        #volumeSlider, #seekBar {
             appearance: none; height: 8px;
             border-radius: 4px; outline: none; cursor: pointer;
             transition: opacity .2s, background-color 0.3s ease; opacity: 0.7;
             background: var(--slider-track);
        }
        #volumeSlider { width: 100px; vertical-align: middle; }
        #seekBar { flex-grow: 1; }

        #volumeSlider:hover, #seekBar:hover { opacity: 1; }
        #seekBar:disabled { cursor: not-allowed; opacity: 0.4; }
        #seekBar:enabled:active { cursor: grabbing; } 


        #volumeSlider {
            background: linear-gradient(to right, var(--slider-thumb-volume) 0%, var(--slider-thumb-volume) var(--volume-percent, 50%), var(--slider-track) var(--volume-percent, 50%), var(--slider-track) 100%);
        }
        #volumeSlider::-moz-range-progress { background-color: var(--slider-thumb-volume); border-radius: 4px; }
        #volumeSlider::-moz-range-track { background-color: var(--slider-track); border-radius: 4px; }

        #seekBar {
             background: linear-gradient(to right, var(--slider-thumb-seek) 0%, var(--slider-thumb-seek) var(--seek-percent, 0%), var(--slider-track) var(--seek-percent, 0%), var(--slider-track) 100%);
        }
        #seekBar::-moz-range-progress { background-color: var(--slider-thumb-seek); border-radius: 4px; }
        #seekBar::-moz-range-track { background-color: var(--slider-track); border-radius: 4px; }


        #volumeSlider::-webkit-slider-thumb { appearance: none; width: 16px; height: 16px; background: var(--slider-thumb-volume); border-radius: 50%; cursor: pointer; transition: background-color 0.3s ease; }
        #volumeSlider::-moz-range-thumb { width: 16px; height: 16px; background: var(--slider-thumb-volume); border-radius: 50%; cursor: pointer; border: none; transition: background-color 0.3s ease; }
        #seekBar::-webkit-slider-thumb { appearance: none; width: 16px; height: 16px; background: var(--slider-thumb-seek); border-radius: 50%; cursor: pointer; margin-top: -4px; transition: background-color 0.3s ease; }
        #seekBar::-moz-range-thumb { width: 16px; height: 16px; background: var(--slider-thumb-seek); border-radius: 50%; cursor: pointer; border: none; transition: background-color 0.3s ease; }


        #visualizerSelect { vertical-align: middle; outline: none; background-color: var(--bg-tertiary); color: var(--text-primary); border-color: var(--border-primary); transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease; }
        #visualizerSelect:hover { background-color: var(--bg-quaternary); }
        #fileUploadLabel { vertical-align: middle; display: inline-block; outline: none; }
        #fileNameDisplay { vertical-align: middle; max-width: 120px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; display: inline-block; color: var(--text-tertiary); transition: color 0.3s ease;}
        #playPauseButton, #skipBackButton, #skipForwardButton { vertical-align: middle; outline: none; }

        .time-display { font-size: 0.8rem; color: var(--text-secondary); min-width: 35px; text-align: center; white-space: nowrap; transition: color 0.3s ease;}
        .volume-percent-display {
            font-size: 0.8rem; color: var(--text-secondary); min-width: 35px; text-align: right; white-space: nowrap; transition: color 0.3s ease; display: inline-block; vertical-align: middle; margin-left: 4px; 
        }
        .db-display {
            font-size: 0.8rem; color: var(--text-tertiary); min-width: 50px; text-align: right; white-space: nowrap; transition: color 0.3s ease, opacity 0.5s ease;  display: inline-block; vertical-align: middle; margin-left: 8px; opacity: 0.7; 
        }
        .db-display.active { opacity: 1.0; } 


        nav {
            background-color: var(--bg-secondary);
            padding: 0.75rem 1rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            flex-shrink: 0; 
            transition: background-color 0.3s ease;
            position: relative; 
            height: 50px; 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
        }
        .nav-left, .nav-right {
            display: flex;
            align-items: center;
        }
        .nav-left { gap: 0.5rem; }
        .nav-right { gap: 0.75rem; }

        .nav-button, .nav-link { 
            color: var(--text-secondary);
            text-decoration: none;
            padding: 0.5rem 1rem;
            border-radius: 0.375rem; 
            transition: background-color 0.2s ease, color 0.2s ease;
            font-weight: 500; 
            cursor: pointer;
            background-color: var(--button-nav-bg);
            border: 1px solid var(--border-secondary);
        }
        .nav-button:hover, .nav-link:hover {
            background-color: var(--button-nav-hover);
            color: var(--text-primary);
        }
        .nav-link.active-link { 
            background-color: var(--button-nav-active-bg);
            color: var(--text-primary);
            font-weight: 600; 
        }

        #theme-toggle {
            background-color: var(--theme-toggle-bg);
            color: var(--text-primary);
            border: none;
            padding: 0.4rem 0.6rem;
            border-radius: 0.375rem; 
            cursor: pointer;
            font-size: 0.9rem;
            line-height: 1;
            transition: background-color 0.2s ease, color 0.2s ease;
        }
        #theme-toggle:hover {
            background-color: var(--theme-toggle-hover);
        }
        #theme-toggle::before {
            content: var(--theme-toggle-icon); 
        }


        .content-section { 
            margin-bottom: 1.5rem;
            transition: background-color 0.3s ease;
        }
        .content-section h2 {
             font-size: 1.5rem; 
             font-weight: 600; 
             color: var(--text-primary);
             margin-bottom: 1rem;
             border-bottom: 1px solid var(--border-primary);
             padding-bottom: 0.5rem;
             transition: color 0.3s ease, border-color 0.3s ease;
        }
         .content-section p, .content-section li {
            color: var(--text-secondary);
            line-height: 1.6;
            margin-bottom: 0.75rem;
            transition: color 0.3s ease;
        }
        .content-section ul { list-style: disc; padding-left: 1.5rem; }
        .content-section ol { list-style: decimal; padding-left: 1.5rem; }
        .content-section a {
            color: var(--text-link);
            text-decoration: underline;
            transition: color 0.2s ease;
        }
        .content-section a:hover { color: var(--text-link-hover); }
        .tech-icon { display: inline-block; margin-right: 0.5rem; font-size: 1.2rem; }
        .content-section .text-gray-400 { color: var(--text-tertiary); transition: color 0.3s ease; }
        .text-white { color: var(--text-primary); transition: color 0.3s ease; } 
        .text-gray-100 { color: var(--text-primary); transition: color 0.3s ease; }
        .text-gray-200 { color: var(--text-primary); transition: color 0.3s ease; } 
        .text-gray-300 { color: var(--text-secondary); transition: color 0.3s ease; }

        #fileUploadLabel {
            background-color: var(--button-choose-bg);
            border-color: var(--button-choose-border);
            color: white; 
        }
        #fileUploadLabel:hover { background-color: var(--button-choose-hover); }

        #playPauseButton, #skipBackButton, #skipForwardButton {
            color: white; 
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        .play-state { background-color: var(--button-play-bg); border-color: var(--button-play-border); }
        .play-state:hover { background-color: var(--button-play-hover); }
        .pause-state { background-color: var(--button-pause-bg); border-color: var(--button-pause-border); }
        .pause-state:hover { background-color: var(--button-pause-hover); }
        .loading-state { background-color: var(--button-load-bg); border-color: var(--button-load-border); cursor: not-allowed; }
        .loading-state:hover { background-color: var(--button-load-hover); }

        #skipBackButton, #skipForwardButton {
            background-color: var(--button-skip-bg);
            border-color: var(--button-skip-border);
            padding-left: 0.75rem; 
            padding-right: 0.75rem; 
        }
        #skipBackButton:hover, #skipForwardButton:hover {
            background-color: var(--button-skip-hover);
        }
        #skipBackButton:disabled, #skipForwardButton:disabled {
            background-color: var(--button-skip-disabled-bg);
            color: var(--button-skip-disabled-text);
            cursor: not-allowed;
            opacity: 0.6;
        }


        #visualizerSelect option {
             background-color: var(--bg-secondary); 
             color: var(--text-primary);
        }
        .light-mode #visualizerSelect option {
            background-color: var(--bg-primary); 
             color: var(--text-primary);
        }

        /* NEW: Mobile Overlay */
        #mobile-overlay {
            transition: opacity 0.3s ease-in-out;
        }

        /* NEW: Responsive Styles for Mobile */
        @media (max-width: 640px) {
            /* Main layout stacking */
            #visualizer-page {
                flex-direction: column !important;
            }

            /* --- Sidebar Overhaul for Mobile --- */
            #info-sidebar, #playlist-sidebar {
                width: 100vw !important;
                max-width: 100vw !important;
                height: 75vh;
                position: fixed !important;
                bottom: 0 !important;
                left: 0 !important;
                top: unset !important;
                transform: translateY(100%);
                transition: transform 0.3s ease-in-out;
                z-index: 1000;
                border-left: none !important;
                border-right: none !important;
                border-top: 2px solid var(--border-primary);
            }

            /* Override info-sidebar's desktop transform and position */
            #info-sidebar {
                transform: translateY(100%);
            }

            /* The 'open' state for both sidebars */
            #info-sidebar.open, #playlist-sidebar.open {
                transform: translateY(0) !important;
            }

            /* --- UI Controls Adjustments --- */
            #ui-container {
                padding: 0.75rem;
                backdrop-filter: blur(2px);
            }

            #controls-row {
                gap: 0.5rem;
            }

            #controls-row h1 {
                font-size: 1.125rem;
                text-align: center;
                width: 100%;
            }
            
            #controls-row .flex.items-center.flex-wrap {
                gap: 0.5rem;
                justify-content: center;
            }

            #visualizerSelect, #fileUploadLabel, #playPauseButton, #skipBackButton, #skipForwardButton {
                padding: 0.4rem 0.6rem;
                font-size: 0.8rem;
            }

            #timeline-row {
                gap: 0.5rem;
            }
            .time-display {
                font-size: 0.75rem;
            }

            #volumeSlider {
                width: 80px;
            }
            .volume-percent-display {
                font-size: 0.75rem;
            }
            .db-display {
                display: none;
            }
            
            .playlist-item-name {
                font-size: 0.8rem;
            }
        }

    </style>
</head>
<body>

    <nav>
        <div class="nav-left">
            <button id="menu-toggle-button" class="nav-button">Menu</button>
             <!-- This button is only shown on small screens -->
            <button id="playlist-toggle-button" class="nav-button sm:hidden">Playlist</button>
            <!-- This link is hidden on small screens -->
            <a href="#visualizer" id="visualizer-nav-link" class="nav-link active-link hidden sm:inline-flex">Visualizer</a>
        </div>
        <div class="nav-right">
            <button id="theme-toggle" title="Toggle Theme"></button>
        </div>
    </nav>

    <div id="info-sidebar">
        <!-- Info sidebar content remains the same -->
        <div id="home-page-content" class="content-section">
            <div class="text-center mb-12">
                <h1 class="text-4xl sm:text-5xl font-bold text-white mb-4">Experience Your Music</h1>
                <p class="text-lg sm:text-xl text-gray-300 mb-8">
                    Dive into an interactive 3D visualization generated in real-time from your favorite MP3s. Now with playlist support!
                </p>
                <button id="launch-visualizer-from-home" class="bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-3 px-8 rounded-lg transition duration-300 text-lg shadow-md">
                    Go to Visualizer
                </button>
            </div>
            <div class="content-section"> <h2>Key Features</h2>
                <ul>
                    <li>Upload and play your own MP3 files.</li>
                    <li><strong>Playlist Support:</strong> Select multiple MP3s, play them sequentially, and skip tracks.</li>
                    <li><strong>Interactive Playlist:</strong> View your queue, play tracks directly from the list, and see the current track highlighted.</li>
                    <li>Real-time 3D visualization that reacts to audio frequencies.</li>
                    <li>Multiple distinct visualizer styles: Bars, Circle, and Waveform Lines.</li>
                    <li>Interactive 3D view: Rotate, pan, and zoom using your mouse.</li>
                    <li>Standard audio controls: Play/Pause, seek bar, volume control.</li>
                    <li>Volume percentage display and approximate decibel meter.</li>
                    <li>Responsive design for various screen sizes.</li>
                    <li>Dynamic background color changes based on music intensity.</li>
                    <li>Light and Dark mode support.</li>
                    <li><strong>NEW:</strong> Add multiple songs to the playlist.</li>
                    <li><strong>NEW:</strong> Remove individual songs from the playlist.</li>
                    <li><strong>NEW:</strong> Clear the entire playlist.</li>
                    <li><strong>NEW:</strong> Drag and drop to reorder tracks in the playlist.</li>
                </ul>
            </div>
             <div class="content-section"> <h2>Technologies Used</h2>
                <p>This application leverages modern web technologies to create a rich frontend experience:</p>
                <ul>
                    <li><span class="tech-icon">üåê</span> <span class="font-semibold">HTML:</span> Structure and content foundation.</li>
                    <li><span class="tech-icon">üé®</span> <span class="font-semibold">Tailwind CSS & CSS Variables:</span> Styling and theming.</li>
                    <li><span class="tech-icon">‚öôÔ∏è</span> <span class="font-semibold">JavaScript:</span> Core application logic, interactivity, and API integration.</li>
                    <li><span class="tech-icon">üßä</span> <span class="font-semibold">Three.js:</span> Powerful 3D graphics library for visualizations.</li>
                    <li><span class="tech-icon">üîä</span> <span class="font-semibold">Web Audio API:</span> Processing and analyzing audio data.</li>
                    <li><span class="tech-icon">üíæ</span> <span class="font-semibold">LocalStorage:</span> Saving user theme preference.</li>
                </ul>
                 <p class="mt-4 text-sm text-gray-400">Note: The "Waveform Lines" visualizer shows a history of the audio spectrum.</p>
            </div>
        </div>

        <div id="about-page-content" class="content-section" style="display: none;"> <div class="text-center mb-12">
                 <h1 class="text-4xl sm:text-5xl font-bold text-white mb-4">About This Visualizer</h1>
                 <p class="text-lg text-gray-300">Bringing music to life with code.</p>
             </div>
             <div class="content-section">
                <h2>How It Works</h2>
                <p>
                    This application uses the browser's built-in <strong>Web Audio API</strong> to analyze the music you play.
                    Specifically, it performs a Fast Fourier Transform (FFT) to get frequency data in real-time. It also calculates the average intensity across frequencies to provide a basic level meter (shown as dB).
                </p>
                <p>
                    This frequency data is then used to manipulate 3D objects created with <strong>Three.js</strong>.
                    The <strong>OrbitControls</strong> addon for Three.js allows you to interact with the 3D scene.
                </p>
             </div>
             <div class="content-section">
                <h2>How to Use</h2>
                <ol>
                    <li>Click the "Menu" button to open the info panel (if not already open).</li>
                    <li>Click the "<strong class="font-semibold">Add MP3(s)</strong>" button (previously "Choose MP3s") and select one or more MP3 files. You can add more files later.</li>
                    <li>The selected tracks will appear in the playlist on the right.</li>
                    <li>Click and drag tracks within the playlist to reorder them.</li>
                    <li>Click the Play button next to a track in the playlist, or use the main Play button in the top controls.</li>
                    <li>Click the '‚úñ' next to a track to remove it.</li>
                    <li>Click "Clear" in the playlist header to remove all tracks.</li>
                    <li>Use skip buttons, volume, seek bar, and visualizer controls as before.</li>
                </ol>
             </div>
             <div class="content-section">
                <h2>Resources</h2>
                <p>Key libraries and technologies used:</p>
                <ul>
                    <li><a href="https://threejs.org/" target="_blank" rel="noopener noreferrer">Three.js</a></li>
                    <li><a href="https://tailwindcss.com/" target="_blank" rel="noopener noreferrer">Tailwind CSS</a></li>
                    <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API" target="_blank" rel="noopener noreferrer">Web Audio API</a></li>
                </ul>
             </div>
              <div class="content-section text-center text-gray-400 text-sm">
                  <p>Created by AI Assistant - 2025</p>
                  <p>Location context: North River, Nova Scotia, Canada</p>
                  <p>Current Time: <span id="current-time-display-about">Loading...</span></p>
              </div>
        </div>
        <div class="mt-4 p-2 border-t border-[var(--border-primary)]">
            <button data-infotarget="home-page-content" class="nav-button info-sidebar-nav-button active-info-link w-full text-left mb-1">Home</button>
            <button data-infotarget="about-page-content" class="nav-button info-sidebar-nav-button w-full text-left">About</button>
        </div>
    </div>


    <div id="page-container">
        <div id="visualizer-page">
            <div id="main-content-area">
                <div id="ui-container">
                    <div id="controls-row" class="flex flex-col sm:flex-row justify-between items-center gap-3 mb-3">
                        <h1 class="text-xl md:text-2xl font-bold text-gray-100 order-1 sm:order-none">3D Music Visualizer</h1>
                        <div class="flex items-center flex-wrap justify-center sm:justify-end gap-2 md:gap-3 order-2 sm:order-none"> 
                            <select id="visualizerSelect"
                                    class="text-sm font-bold py-2 px-3 rounded cursor-pointer transition duration-300 ease-in-out border hover:shadow-md focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50">
                                <option value="BARS">Bars</option>
                                <option value="CIRCLE">Circle</option>
                                <option value="WAVEFORM_LINES">Waveform Lines</option>
                            </select>
                            <div class="flex items-center">
                                <input type="file" id="audioFile" accept=".mp3" class="hidden" multiple> 
                                <label for="audioFile" id="fileUploadLabel"
                                       class="inline-block text-sm font-bold py-2 px-4 rounded cursor-pointer transition duration-300 ease-in-out border hover:shadow-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">
                                    Add MP3(s) </label>
                                <span id="fileNameDisplay" title="No file selected"
                                      class="ml-2 text-sm italic">
                                    </span>
                            </div>
                            <button id="skipBackButton" title="Previous Track"
                                    class="font-bold py-2 px-3 rounded transition duration-300 ease-in-out text-sm border hover:shadow-md focus:outline-none focus:ring-2 focus:ring-opacity-50"
                                    disabled>
                                &#9664;&#9664; 
                            </button>
                            <button id="playPauseButton"
                                    class="font-bold py-2 px-4 rounded transition duration-300 ease-in-out text-sm border hover:shadow-md focus:outline-none focus:ring-2 focus:ring-opacity-50"
                                    disabled>
                                Play
                            </button>
                            <button id="skipForwardButton" title="Next Track"
                                    class="font-bold py-2 px-3 rounded transition duration-300 ease-in-out text-sm border hover:shadow-md focus:outline-none focus:ring-2 focus:ring-opacity-50"
                                    disabled>
                                 &#9654;&#9654; 
                            </button>
                            <div class="flex items-center">
                                <input type="range" id="volumeSlider" min="0" max="100" value="50" title="Volume">
                                <span id="volumePercentageDisplay" class="volume-percent-display">50%</span>
                            </div>
                             <div class="flex items-center">
                                <span class="text-xs text-gray-400 mr-1">Level:</span>
                                <span id="dbValueDisplay" class="db-display">-‚àû dB</span>
                             </div>
                        </div>
                    </div>
    
                    <div id="timeline-row" class="flex items-center gap-3">
                        <span id="currentTime" class="time-display">0:00</span>
                        <input type="range" id="seekBar" min="0" max="100" value="0" step="0.1" class="flex-grow" disabled>
                        <span id="totalDuration" class="time-display">0:00</span>
                    </div>
                </div>
                <canvas id="visualizer-canvas"></canvas>
            </div>

            <div id="playlist-sidebar">
                <div id="playlist-header">
                    <h3>Current Playlist</h3>
                    <button id="clear-playlist-button" title="Clear entire playlist" disabled>Clear</button>
                </div>
                <div id="playlist-items-container">
                    <p id="empty-playlist-message">No tracks loaded. Click "Add MP3(s)" to add songs.</p>
                </div>
            </div>
        </div>
        </div>
    <div id="message-box"></div>
    <!-- NEW: Mobile overlay -->
    <div id="mobile-overlay" class="fixed inset-0 bg-black bg-opacity-50 z-[999] hidden"></div>


    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Constants ---
        const VisualizerType = { BARS: 'BARS', CIRCLE: 'CIRCLE', WAVEFORM_LINES: 'WAVEFORM_LINES' };
        const FFT_SIZE = 256; 
        const NUM_BINS = FFT_SIZE / 2; 
        const DB_MIN = -60; 
        const DB_MAX = 0;   
        const DB_UPDATE_INTERVAL = 1500; 

        // --- Waveform Lines Constants ---
        const WF_NUM_LINES = 50;      
        const WF_LINE_LENGTH = NUM_BINS; 
        const WF_VERTICAL_SCALE = 50; 
        const WF_X_SPREAD = 200;      
        const WF_Z_SPREAD = 150;      
        const WF_SMOOTHING_FACTOR = 0.8; 
        const WF_COLOR_SATURATION = 1.0;
        const WF_COLOR_LIGHTNESS = 0.6;
        const WF_RESET_LERP_FACTOR = 0.1; 

        // --- Class Lists for Button States ---
        const playButtonStateClasses = ['play-state'];
        const pauseButtonStateClasses = ['pause-state'];
        const loadingButtonStateClasses = ['loading-state'];

        // --- Global Variables ---
        let scene, camera, renderer, analyser, audio, audioContext, audioSource;
        let controls; 
        let currentVisualizerObjects = []; 
        let currentVisualizerType = VisualizerType.BARS; 
        let isPlaying = false;
        let hasAudioContextStarted = false; 
        let startTime = 0; 
        let pauseTime = 0; 
        let animationFrameId = null; 
        let isVisualizerInitialized = false; 
        let currentTheme = 'dark'; 
        let isSeeking = false; 
        let lastDbUpdateTime = 0; 
        let dbTimeoutId = null; 

        // --- Playlist Variables ---
        let playlist = []; 
        let currentTrackIndex = -1; 
        let isLoadingTrack = false; 
        let draggedItem = null;
        let dragOverItem = null;


        // --- Waveform Lines specific variables ---
        let wfGeometry = null;          
        let wfMaterial = null;          
        let wfLineSegments = null;      
        let wfFrequencyHistory = [];    
        let wfPreviousYValues = [];     

        // --- UI Element References ---
        const bodyElement = document.body;
        const themeToggleButton = document.getElementById('theme-toggle');
        const menuToggleButton = document.getElementById('menu-toggle-button');
        const infoSidebar = document.getElementById('info-sidebar');
        const playlistSidebar = document.getElementById('playlist-sidebar'); // Get playlist sidebar
        const homePageContent = document.getElementById('home-page-content');
        const aboutPageContent = document.getElementById('about-page-content');
        const infoSidebarNavButtons = document.querySelectorAll('.info-sidebar-nav-button');
        const launchVisualizerFromHomeButton = document.getElementById('launch-visualizer-from-home');
        const visualizerNavLink = document.getElementById('visualizer-nav-link');
        // NEW Mobile Elements
        const playlistToggleButton = document.getElementById('playlist-toggle-button');
        const mobileOverlay = document.getElementById('mobile-overlay');


        const audioFileInput = document.getElementById('audioFile');
        const playPauseButton = document.getElementById('playPauseButton');
        const skipBackButton = document.getElementById('skipBackButton'); 
        const skipForwardButton = document.getElementById('skipForwardButton'); 
        const volumeSlider = document.getElementById('volumeSlider');
        const volumePercentageDisplay = document.getElementById('volumePercentageDisplay');
        const dbValueDisplay = document.getElementById('dbValueDisplay');
        const canvas = document.getElementById('visualizer-canvas');
        const mainContentArea = document.getElementById('main-content-area'); 
        const playlistItemsContainer = document.getElementById('playlist-items-container');
        const emptyPlaylistMessage = document.getElementById('empty-playlist-message');
        const clearPlaylistButton = document.getElementById('clear-playlist-button');
        const messageBox = document.getElementById('message-box');
        const visualizerSelect = document.getElementById('visualizerSelect');
        const fileNameDisplay = document.getElementById('fileNameDisplay'); 
        const seekBar = document.getElementById('seekBar');
        const currentTimeDisplay = document.getElementById('currentTime');
        const totalDurationDisplay = document.getElementById('totalDuration');
        const currentTimeAboutDisplay = document.getElementById('current-time-display-about'); 

        // --- Theme Switching Logic ---
        function applyTheme(theme) {
            if (theme === 'light') {
                bodyElement.classList.add('light-mode');
                currentTheme = 'light';
            } else {
                bodyElement.classList.remove('light-mode');
                currentTheme = 'dark';
            }
            updateRangeInputFill(volumeSlider, 'volume');
            updateRangeInputFill(seekBar, 'seek');
            localStorage.setItem('visualizerTheme', theme); 
        }
        function toggleTheme() {
            const newTheme = bodyElement.classList.contains('light-mode') ? 'dark' : 'light';
            applyTheme(newTheme);
        }
        const savedTheme = localStorage.getItem('visualizerTheme') || 'dark';
        applyTheme(savedTheme);
        themeToggleButton.addEventListener('click', toggleTheme);

        // --- MODIFIED: Sidebar Logic for Mobile Responsiveness ---
        function openPlaylistSidebar() {
            if (window.innerWidth < 640) { // Mobile logic
                closeInfoSidebar(true); // Close other panel without hiding overlay
                mobileOverlay.classList.remove('hidden');
            }
            playlistSidebar.classList.add('open');
        }

        function closePlaylistSidebar(isChaining = false) {
            playlistSidebar.classList.remove('open');
            if (!isChaining && !infoSidebar.classList.contains('open')) {
                mobileOverlay.classList.add('hidden');
            }
        }

        function togglePlaylistSidebar() {
            if (playlistSidebar.classList.contains('open')) {
                closePlaylistSidebar();
            } else {
                openPlaylistSidebar();
            }
        }

        function openInfoSidebar() {
            if (window.innerWidth < 640) { // Mobile logic
                closePlaylistSidebar(true); // Close other panel
                mobileOverlay.classList.remove('hidden');
            }
            infoSidebar.classList.add('open');
            menuToggleButton.setAttribute('aria-expanded', 'true');
        }

        function closeInfoSidebar(isChaining = false) {
            infoSidebar.classList.remove('open');
            menuToggleButton.setAttribute('aria-expanded', 'false');
            if (!isChaining && !playlistSidebar.classList.contains('open')) {
                mobileOverlay.classList.add('hidden');
            }
        }

        function toggleInfoSidebar() {
            if (infoSidebar.classList.contains('open')) {
                closeInfoSidebar();
            } else {
                openInfoSidebar();
            }
        }
        
        // --- Update Range Input Fill ---
        function updateRangeInputFill(inputElement, type) {if (!inputElement) return; const value = parseFloat(inputElement.value) || 0; const min = parseFloat(inputElement.min) || 0; const max = parseFloat(inputElement.max) || 100; const percentage = ((value - min) / (max - min)) * 100; const computedStyle = getComputedStyle(inputElement);  const filledColor = computedStyle.getPropertyValue(type === 'volume' ? '--slider-thumb-volume' : '--slider-thumb-seek').trim(); const unfilledColor = computedStyle.getPropertyValue('--slider-track').trim(); inputElement.style.background = `linear-gradient(to right, ${filledColor} 0%, ${filledColor} ${percentage}%, ${unfilledColor} ${percentage}%, ${unfilledColor} 100%)`; inputElement.style.setProperty(type === 'volume' ? '--volume-percent' : '--seek-percent', `${percentage}%`);}
        function updateVolumePercentageDisplay() {if (volumeSlider && volumePercentageDisplay) {volumePercentageDisplay.textContent = `${volumeSlider.value}%`;}}
        function mapRange(value, inMin, inMax, outMin, outMax) {const clampedValue = Math.max(inMin, Math.min(value, inMax)); return ((clampedValue - inMin) * (outMax - outMin) / (inMax - inMin)) + outMin;}

        // --- Visualizer Initialization ---
        function initVisualizer() {
            if (isVisualizerInitialized) return; 
            console.log("Initializing Visualizer...");
            try {
                scene = new THREE.Scene();
                const canvasContainer = mainContentArea; 
                const initialWidth = canvasContainer.clientWidth;
                const initialHeight = canvasContainer.clientHeight;

                camera = new THREE.PerspectiveCamera(75, initialWidth / initialHeight, 0.1, 1000);
                camera.position.set(0, 50, 180); 

                if (!canvas) { console.error("Visualizer canvas not found!"); return; }
                renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
                renderer.setClearColor(0x000000, 0); 
                renderer.setSize(initialWidth, initialHeight);
                renderer.setPixelRatio(window.devicePixelRatio); 

                const listener = new THREE.AudioListener(); 
                camera.add(listener); 
                audio = new THREE.Audio(listener); 
                if (!audioContext) {
                    audioContext = THREE.AudioContext.getContext();
                     if (audioContext.state === 'suspended') {
                        initAudioContextOnInteraction();
                    } else {
                        hasAudioContextStarted = true;
                    }
                }
                analyser = new THREE.AudioAnalyser(audio, FFT_SIZE); 
                audio.setVolume(volumeSlider.value / 100); 
                updateVolumePercentageDisplay(); 

                const ambientLightIntensity = currentTheme === 'light' ? 0.8 : 0.6;
                const pointLightIntensity = currentTheme === 'light' ? 1.0 : 0.9;
                const ambientLight = new THREE.AmbientLight(0xcccccc, ambientLightIntensity);
                scene.add(ambientLight);
                const pointLight = new THREE.PointLight(0xffffff, pointLightIntensity);
                camera.add(pointLight); 
                scene.add(camera); 

                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true; 
                controls.dampingFactor = 0.05;
                controls.screenSpacePanning = false; 
                controls.minDistance = 20;
                controls.maxDistance = 500;
                controls.maxPolarAngle = Math.PI; 
                controls.minPolarAngle = 0;

                currentVisualizerType = visualizerSelect.value; 
                setupVisualizerGeometry(); 
                updatePlayPauseButton(false); 
                updateSkipButtonsState(); 
                resetTimelineUI(); 
                if(dbValueDisplay) {
                    dbValueDisplay.textContent = "-‚àû dB"; 
                    dbValueDisplay.classList.remove('active');
                }
                renderPlaylist();

                // Event listeners are added only once during initialization
                if (!isVisualizerInitialized) { 
                    window.addEventListener('resize', onWindowResize, false);
                    
                    // Sidebar and Nav Listeners
                    menuToggleButton.addEventListener('click', toggleInfoSidebar);
                    playlistToggleButton.addEventListener('click', togglePlaylistSidebar);
                    mobileOverlay.addEventListener('click', () => {
                        closeInfoSidebar();
                        closePlaylistSidebar();
                    });
                    visualizerNavLink.addEventListener('click', (e) => {e.preventDefault(); closeInfoSidebar(); if (!isVisualizerInitialized) initVisualizer(); else onWindowResize();});
                    if(launchVisualizerFromHomeButton) {launchVisualizerFromHomeButton.addEventListener('click', () => {closeInfoSidebar(); if (!isVisualizerInitialized) initVisualizer(); else onWindowResize();});}
                    infoSidebarNavButtons.forEach(button => {button.addEventListener('click', () => {const targetId = button.dataset.infotarget; if(homePageContent) homePageContent.style.display = 'none'; if(aboutPageContent) aboutPageContent.style.display = 'none'; const targetSection = document.getElementById(targetId); if (targetSection) targetSection.style.display = 'block'; infoSidebarNavButtons.forEach(btn => btn.classList.remove('active-info-link')); button.classList.add('active-info-link'); if (targetId === 'about-page-content') updateTimeDisplay();});});


                    // Audio and Control Listeners
                    audioFileInput.addEventListener('change', handleFileSelect, false);
                    playPauseButton.addEventListener('click', togglePlayPause, false);
                    skipBackButton.addEventListener('click', handleSkipBack, false);
                    skipForwardButton.addEventListener('click', handleSkipForward, false);
                    clearPlaylistButton.addEventListener('click', handleClearPlaylist);

                    volumeSlider.addEventListener('input', () => {
                        handleVolumeChange();
                        updateRangeInputFill(volumeSlider, 'volume'); 
                        updateVolumePercentageDisplay(); 
                    });
                    visualizerSelect.addEventListener('change', handleVisualizerChange, false);

                    seekBar.addEventListener('pointerdown', () => { isSeeking = true; });
                    seekBar.addEventListener('pointerup', () => {
                        if (isSeeking) {
                            isSeeking = false;
                            handleSeekChange(); 
                        }
                    });
                    seekBar.addEventListener('input', () => {
                        if (isSeeking) {
                            handleSeekInput();
                            updateRangeInputFill(seekBar, 'seek');
                        }
                    });
                    seekBar.addEventListener('pointerleave', () => {});

                    // Drag and Drop Event Listeners for Playlist
                    playlistItemsContainer.addEventListener('dragstart', handleDragStart);
                    playlistItemsContainer.addEventListener('dragover', handleDragOver);
                    playlistItemsContainer.addEventListener('dragleave', handleDragLeave);
                    playlistItemsContainer.addEventListener('drop', handleDrop);
                    playlistItemsContainer.addEventListener('dragend', handleDragEnd);
                }


                updateRangeInputFill(seekBar, 'seek');
                updateRangeInputFill(volumeSlider, 'volume');

                isVisualizerInitialized = true;
                startAnimationLoop(); 
            } catch (error) {
                console.error("Error during visualizer initialization:", error);
                showMessage("Failed to initialize visualizer.", 5000);
            }
        }

        // --- Time Formatting and UI Reset ---
        function formatTime(seconds) { if (isNaN(seconds) || seconds < 0) return '0:00'; const minutes = Math.floor(seconds / 60); const secs = Math.floor(seconds % 60); return `${minutes}:${secs < 10 ? '0' : ''}${secs}`; }
        function resetTimelineUI() { seekBar.value = 0; seekBar.disabled = true; currentTimeDisplay.textContent = '0:00'; totalDurationDisplay.textContent = '0:00'; updateRangeInputFill(seekBar, 'seek'); }
        
        // --- Visualizer Geometry Setup and Clearing ---
        function setupVisualizerGeometry() {clearVisualizerGeometry(); switch (currentVisualizerType) {case VisualizerType.BARS: createBarsVisualizer(); if(controls) controls.target.set(0, 25, 0); camera.position.set(0, 50, 180); break; case VisualizerType.CIRCLE: createCircleVisualizer(); if(controls) controls.target.set(0, 0, 0); camera.position.set(0, 0, 180); break; case VisualizerType.WAVEFORM_LINES: createWaveformLinesVisualizer(); if(controls) controls.target.set(0, WF_VERTICAL_SCALE * 0.1, -WF_Z_SPREAD * 0.2); camera.position.set(0, WF_VERTICAL_SCALE * 0.5, WF_Z_SPREAD * 0.8); break; default: createBarsVisualizer(); if(controls) controls.target.set(0, 25, 0); camera.position.set(0, 50, 180);} if (controls) controls.update();}
        function clearVisualizerGeometry() {currentVisualizerObjects.forEach(obj => {if (obj) {if (obj.geometry) obj.geometry.dispose(); if (obj.material) {if (Array.isArray(obj.material)) {obj.material.forEach(m => m.dispose());} else {obj.material.dispose();}} if (scene) scene.remove(obj);}}); currentVisualizerObjects = []; wfGeometry = null; wfMaterial = null; wfLineSegments = null; wfFrequencyHistory = []; wfPreviousYValues = [];}
        function handleVisualizerChange(event) {currentVisualizerType = event.target.value; setupVisualizerGeometry();}
        function createBarsVisualizer() {if (!scene) return; const barWidth = 2, barSpacing = 1; const totalWidth = NUM_BINS * (barWidth + barSpacing) - barSpacing; const startX = -totalWidth / 2; const material = new THREE.MeshPhongMaterial({ specular: 0x555555, shininess: 30, vertexColors: true }); for (let i = 0; i < NUM_BINS; i++) {const geometry = new THREE.BoxGeometry(barWidth, 1, barWidth); geometry.translate(0, 0.5, 0); const colors = []; const color = new THREE.Color(); for (let j = 0; j < geometry.attributes.position.count; j++) {color.setHSL(i / NUM_BINS, 1.0, 0.5); colors.push(color.r, color.g, color.b);} geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3)); const cube = new THREE.Mesh(geometry, material); cube.position.set(startX + i * (barWidth + barSpacing), 0, 0); scene.add(cube); currentVisualizerObjects.push(cube);}}
        function createCircleVisualizer() {if (!scene) return; const radius = 50, barWidth = 1.5, barDepth = 5; const material = new THREE.MeshPhongMaterial({ specular: 0x555555, shininess: 30, vertexColors: true }); for (let i = 0; i < NUM_BINS; i++) {const angle = (i / NUM_BINS) * Math.PI * 2; const geometry = new THREE.BoxGeometry(barWidth, 1, barDepth); geometry.translate(0, 0.5, 0); const colors = []; const color = new THREE.Color(); for (let j = 0; j < geometry.attributes.position.count; j++) {color.setHSL(i / NUM_BINS, 1.0, 0.5); colors.push(color.r, color.g, color.b);} geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3)); const cube = new THREE.Mesh(geometry, material); cube.position.set(radius * Math.cos(angle), 0, radius * Math.sin(angle)); cube.lookAt(0, 0, 0); scene.add(cube); currentVisualizerObjects.push(cube);}}
        function createWaveformLinesVisualizer() {if (!scene) return; wfGeometry = new THREE.BufferGeometry(); const totalVertices = WF_NUM_LINES * WF_LINE_LENGTH; const positions = new Float32Array(totalVertices * 3); const colors = new Float32Array(totalVertices * 3); const indices = []; const color = new THREE.Color(); wfFrequencyHistory = []; wfPreviousYValues = []; for (let i = 0; i < WF_NUM_LINES; i++) {wfFrequencyHistory.push(new Uint8Array(WF_LINE_LENGTH).fill(0)); wfPreviousYValues.push(new Float32Array(WF_LINE_LENGTH).fill(0));} for (let lineIndex = 0; lineIndex < WF_NUM_LINES; lineIndex++) {for (let pointIndex = 0; pointIndex < WF_LINE_LENGTH; pointIndex++) {const vertexIndex = lineIndex * WF_LINE_LENGTH + pointIndex; const i3 = vertexIndex * 3; const x = (pointIndex / (WF_LINE_LENGTH - 1) - 0.5) * WF_X_SPREAD; const y = 0; const z = (lineIndex / (WF_NUM_LINES - 1) - 0.5) * WF_Z_SPREAD; positions[i3] = x; positions[i3 + 1] = y; positions[i3 + 2] = z; color.setHSL(pointIndex / WF_LINE_LENGTH, WF_COLOR_SATURATION, WF_COLOR_LIGHTNESS * 0.5); colors[i3] = color.r; colors[i3 + 1] = color.g; colors[i3 + 2] = color.b; if (pointIndex < WF_LINE_LENGTH - 1) {indices.push(vertexIndex, vertexIndex + 1);}}} wfGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3)); wfGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3)); wfGeometry.setIndex(indices); wfMaterial = new THREE.LineBasicMaterial({ vertexColors: true }); wfLineSegments = new THREE.LineSegments(wfGeometry, wfMaterial); scene.add(wfLineSegments); currentVisualizerObjects.push(wfLineSegments);}

        // --- Playlist Rendering and Management ---
        function renderPlaylist() {
            if (!playlistItemsContainer || !emptyPlaylistMessage || !clearPlaylistButton) return;
            playlistItemsContainer.innerHTML = '';

            if (playlist.length === 0) {
                emptyPlaylistMessage.style.display = 'block';
                playlistItemsContainer.appendChild(emptyPlaylistMessage);
                clearPlaylistButton.disabled = true;
            } else {
                emptyPlaylistMessage.style.display = 'none';
                clearPlaylistButton.disabled = false;

                playlist.forEach((track, index) => {
                    const itemDiv = document.createElement('div');
                    itemDiv.classList.add('playlist-item');
                    itemDiv.dataset.index = index;
                    itemDiv.setAttribute('draggable', 'true');

                    if (index === currentTrackIndex) {
                        itemDiv.classList.add('active-track');
                    }

                    const nameSpan = document.createElement('span');
                    nameSpan.classList.add('playlist-item-name');
                    nameSpan.textContent = track.name;
                    nameSpan.title = track.name;

                    const controlsDiv = document.createElement('div');
                    controlsDiv.classList.add('playlist-item-controls');

                    const trackPlayPauseButton = document.createElement('button');
                    trackPlayPauseButton.classList.add('playlist-item-button');
                    trackPlayPauseButton.textContent = (index === currentTrackIndex && isPlaying) ? 'Pause' : 'Play';
                    trackPlayPauseButton.addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (isLoadingTrack) return;
                        if (index === currentTrackIndex) {
                            togglePlayPause();
                        } else {
                            loadTrack(index, true);
                        }
                    });

                    const removeButton = document.createElement('button');
                    removeButton.classList.add('playlist-item-remove-button');
                    removeButton.innerHTML = '&times;';
                    removeButton.title = 'Remove track';
                    removeButton.addEventListener('click', (e) => {
                        e.stopPropagation();
                        removeTrack(index);
                    });

                    controlsDiv.appendChild(trackPlayPauseButton);
                    controlsDiv.appendChild(removeButton);

                    itemDiv.appendChild(nameSpan);
                    itemDiv.appendChild(controlsDiv);
                    playlistItemsContainer.appendChild(itemDiv);
                });
            }
        }

        function removeTrack(indexToRemove) {
            if (indexToRemove < 0 || indexToRemove >= playlist.length) return;

            const removedTrackIsCurrent = (indexToRemove === currentTrackIndex);
            const wasPlayingWhenRemoved = removedTrackIsCurrent && isPlaying; 

            playlist.splice(indexToRemove, 1);

            if (removedTrackIsCurrent) {
                if (audio && audio.isPlaying) { 
                    audio.stop();
                }
                isPlaying = false; 
                pauseTime = 0;
                resetTimelineUI();

                if (playlist.length > 0) {
                    currentTrackIndex = Math.min(indexToRemove, playlist.length - 1); 
                    
                    if (wasPlayingWhenRemoved) {
                         loadTrack(currentTrackIndex, true);
                    } else {
                        updatePlayPauseButton(false); 
                    }
                } else {
                    currentTrackIndex = -1;
                    resetUIOnError();
                }
            } else if (indexToRemove < currentTrackIndex) {
                currentTrackIndex--;
            }
            
            renderPlaylist();
            updateSkipButtonsState();
            if (!removedTrackIsCurrent || playlist.length === 0) {
                updatePlayPauseButton(isPlaying); 
            }
            if (playlist.length === 0) {
                 fileNameDisplay.textContent = '';
                 fileNameDisplay.title = 'No file selected';
            } else {
                 fileNameDisplay.title = `Playlist: ${playlist.length} track(s)`;
            }
        }

        function handleClearPlaylist() {
            if (playlist.length === 0) return;

            if (audio && audio.isPlaying) {
                audio.stop();
            }
            isPlaying = false;
            pauseTime = 0;
            playlist = [];
            currentTrackIndex = -1;
            
            resetUIOnError();
            renderPlaylist();
            showMessage("Playlist cleared.", 3000);
            fileNameDisplay.textContent = '';
            fileNameDisplay.title = 'No file selected';
        }

        function handleFileSelect(event) {
            if (!audioContext) { showMessage("Audio system not ready.", 4000); return; }
            const files = event.target.files; 
            if (!files || files.length === 0) {
                audioFileInput.value = null;
                return;
            }

            let newFilesAdded = false;
            const newTracks = [];

            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                if (file.type.startsWith('audio/mpeg') || file.name.toLowerCase().endsWith('.mp3')) {
                    newTracks.push({ file: file, name: file.name, uniqueId: Date.now() + Math.random().toString(36).substr(2, 9) });
                    newFilesAdded = true;
                } else {
                    showMessage(`Skipped non-MP3 file: ${file.name}`, 3000);
                }
            }

            if (!newFilesAdded) {
                if (playlist.length === 0) {
                     showMessage("No valid MP3 files selected to add.", 4000);
                     resetUIOnError(); 
                     fileNameDisplay.textContent = '';
                     fileNameDisplay.title = 'No valid MP3s';
                }
                audioFileInput.value = null;
                return;
            }
            
            playlist = playlist.concat(newTracks);

            fileNameDisplay.textContent = '';
            fileNameDisplay.title = `Playlist: ${playlist.length} track(s)`;
            
            const shouldAutoLoadFirstNew = currentTrackIndex === -1 && playlist.length > 0;

            if (audioContext.state === 'suspended') {
                audioContext.resume().catch(err => {
                     console.error("Failed to resume AudioContext:", err);
                     showMessage("Audio system failed. Please interact and try again.", 5000);
                     if (playlist.length === newTracks.length) resetUIOnError(); 
                 }).then(() => {
                    if (shouldAutoLoadFirstNew) {
                        currentTrackIndex = playlist.length - newTracks.length;
                        loadTrack(currentTrackIndex); 
                    }
                 });
            } else {
                 if (shouldAutoLoadFirstNew) {
                    currentTrackIndex = playlist.length - newTracks.length; 
                    loadTrack(currentTrackIndex); 
                }
            }
            updateSkipButtonsState();
            renderPlaylist(); 
            showMessage(`${newTracks.length} track(s) added to playlist.`, 2500);
            audioFileInput.value = null;
        }

        function loadTrack(index, autoPlay = false) {
            if (isLoadingTrack || index < 0 || index >= playlist.length) {
                if (index >= playlist.length && playlist.length > 0) { 
                    showMessage("End of playlist.", 3000);
                    currentTrackIndex = -1; 
                    updatePlayPauseButton(false); 
                    resetTimelineUI();
                    fileNameDisplay.textContent = "";
                } else if (playlist.length === 0) {
                    resetUIOnError();
                }
                isLoadingTrack = false; 
                updateSkipButtonsState(); 
                renderPlaylist(); 
                return;
            }
            isLoadingTrack = true;
            currentTrackIndex = index;
            updateSkipButtonsState(); 
            renderPlaylist();

            const track = playlist[index];

            showMessage(`Loading: ${track.name.substring(0,25)}${track.name.length > 25 ? '...' : ''}`);
            playPauseButton.disabled = true; 
            updatePlayPauseButton(false, true); 
            resetTimelineUI();
            if(dbValueDisplay) {
                dbValueDisplay.textContent = "-‚àû dB";
                dbValueDisplay.classList.remove('active');
                lastDbUpdateTime = 0;
                if(dbTimeoutId) clearTimeout(dbTimeoutId);
            }

            if (audio && audio.isPlaying) {
                audio.stop(); 
                isPlaying = false;
            }
            pauseTime = 0; 

            if (currentVisualizerType === VisualizerType.WAVEFORM_LINES && wfFrequencyHistory.length > 0) {
                for (let i = 0; i < WF_NUM_LINES; i++) {
                    if (wfFrequencyHistory[i]) wfFrequencyHistory[i].fill(0);
                    if (wfPreviousYValues[i]) wfPreviousYValues[i].fill(0);
                }
                if(wfGeometry && wfGeometry.attributes.position) {
                    const positions = wfGeometry.attributes.position;
                    for(let i = 0; i < positions.count; i++) { positions.setY(i, 0); }
                    positions.needsUpdate = true;
                }
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                if (playlist[currentTrackIndex] === track) {
                    decodeAudio(e.target.result, track.name, autoPlay);
                } else {
                    console.warn("Track changed during file read, aborting decode for old track.");
                    isLoadingTrack = false;
                    if (currentTrackIndex >= playlist.length && playlist.length > 0) {
                        currentTrackIndex = playlist.length -1;
                        loadTrack(currentTrackIndex, autoPlay);
                    } else if (playlist.length === 0) {
                        resetUIOnError();
                    }
                }
            };
            reader.onerror = (e) => {
                console.error('FileReader error:', e);
                showMessage(`Error reading file: ${track.name}`, 5000);
                isLoadingTrack = false; 
                if (playlist[currentTrackIndex] === track) {
                    if (currentTrackIndex + 1 < playlist.length) {
                        loadTrack(currentTrackIndex + 1, autoPlay); 
                    } else {
                        resetUIOnError(); 
                        updateSkipButtonsState();
                        renderPlaylist();
                    }
                }
            };
            reader.readAsArrayBuffer(track.file);
        }

        function decodeAudio(arrayBuffer, fileName, autoPlayAfterDecode = false) {
             if (!audioContext || !audio) {
                 resetUIOnError(); isLoadingTrack = false; return;
             }
            audioContext.decodeAudioData(arrayBuffer).then(buffer => {
                if (currentTrackIndex === -1 || !playlist[currentTrackIndex] || playlist[currentTrackIndex].name !== fileName) {
                    console.warn(`Decoded audio for ${fileName}, but it's no longer the current track. Aborting setup.`);
                    isLoadingTrack = false;
                    if (!isLoadingTrack) {
                        updatePlayPauseButton(isPlaying);
                        updateSkipButtonsState();
                        renderPlaylist();
                    }
                    return;
                }

                if (audioSource && audioSource.buffer) {
                    try { audioSource.disconnect(); } catch (e) {}
                }
                audio.setBuffer(buffer);
                audio.setVolume(volumeSlider.value / 100);
                updateVolumePercentageDisplay(); 
                audio.offset = 0; 
                const duration = buffer.duration;
                totalDurationDisplay.textContent = formatTime(duration);
                seekBar.max = duration; seekBar.value = 0; seekBar.disabled = false; 
                currentTimeDisplay.textContent = formatTime(0);
                updateRangeInputFill(seekBar, 'seek');
                fileNameDisplay.textContent = ""; 
                showMessage(`Loaded: ${fileName.substring(0,25)}${fileName.length > 25 ? '...' : ''}`, 2000);
                playPauseButton.disabled = false; 
                isLoadingTrack = false; 
                updatePlayPauseButton(false); 
                updateSkipButtonsState(); 
                renderPlaylist(); 
                hasAudioContextStarted = true; 
                pauseTime = 0; isSeeking = false; 
                if (autoPlayAfterDecode) playAudio();
            }).catch(error => {
                console.error(`Error decoding audio data for ${fileName}:`, error);
                let errorMsg = `Error loading ${fileName}.`;
                if (error instanceof DOMException && error.name === 'EncodingError') {
                    errorMsg = `Error decoding ${fileName}: File might be corrupt or not a valid MP3.`;
                }
                showMessage(errorMsg, 5000);
                isLoadingTrack = false;

                const isCurrentLoadingTrack = currentTrackIndex !== -1 && playlist[currentTrackIndex] && playlist[currentTrackIndex].name === fileName;

                if (isCurrentLoadingTrack) {
                    const shouldAttemptNext = autoPlayAfterDecode; 
                    if (shouldAttemptNext && (currentTrackIndex + 1 < playlist.length)) {
                        showMessage(`Skipping to next track as ${fileName} failed.`, 3000);
                        loadTrack(currentTrackIndex + 1, true); 
                    } else {
                        currentTrackIndex = -1; 
                        resetUIOnError(); 
                    }
                } else {
                    updatePlayPauseButton(isPlaying, isLoadingTrack);
                    updateSkipButtonsState();
                    renderPlaylist();
                }
            });
        }

        function resetUIOnError() {  
            playPauseButton.disabled = true;
            updatePlayPauseButton(false); 
            isPlaying = false;
            if (playlist.length === 0) { 
                fileNameDisplay.textContent = '';
                fileNameDisplay.title = 'No file selected';
            } else if (currentTrackIndex === -1 && playlist.length > 0) {
                fileNameDisplay.textContent = "";
                fileNameDisplay.title = `Playlist: ${playlist.length} track(s). Select a track.`;
            }
            resetTimelineUI(); 
            if(dbValueDisplay) {
                dbValueDisplay.textContent = "-‚àû dB"; 
                dbValueDisplay.classList.remove('active');
                lastDbUpdateTime = 0; if(dbTimeoutId) clearTimeout(dbTimeoutId);
            }
            pauseTime = 0; isSeeking = false;
            if (audio && audio.isPlaying) try { audio.stop(); } catch(e) {}
            if (audio && audio.buffer) audio.setBuffer(null); 
            updateSkipButtonsState(); 
            renderPlaylist(); 
        }

        // --- Audio Controls ---
        function togglePlayPause() {
            if (!isVisualizerInitialized) { showMessage("Visualizer not active/ready.", 3000); return; }
            if (isLoadingTrack) { showMessage("Track is loading...", 2000); return; }
            if (currentTrackIndex < 0 && playlist.length > 0) { loadTrack(0, true); return; }
            if (!audio || !audio.buffer || !hasAudioContextStarted || currentTrackIndex < 0) { showMessage("Load MP3(s) first.", 3000); return; }
            if (audioContext.state === 'suspended') { audioContext.resume().catch(err => { console.error("Failed to resume AudioContext on play/pause:", err); showMessage("Could not start audio. Please interact with the page and try again.", 4000); }).then(() => { if (isPlaying) pauseAudio(); else playAudio(); });
            } else { if (isPlaying) pauseAudio(); else playAudio(); }
        }
        function playAudio() {
            if (!audio || !audio.buffer || isPlaying || isLoadingTrack) return; 
            try { audio.offset = pauseTime; audio.play(); startTime = audio.context.currentTime - pauseTime; isPlaying = true; updatePlayPauseButton(true); renderPlaylist(); startAnimationLoop(); } 
            catch (e) { console.error("Error playing audio:", e); showMessage("Error starting playback.", 4000); resetUIOnError(); }
        }
        function pauseAudio() {
             if (!audio || !audio.buffer || !isPlaying) return; 
             try { const currentElapsedTime = audio.context.currentTime - startTime; pauseTime = currentElapsedTime; if (audio.buffer && pauseTime > audio.buffer.duration) pauseTime = audio.buffer.duration; else if (pauseTime < 0) pauseTime = 0; audio.pause(); isPlaying = false; updatePlayPauseButton(false); renderPlaylist(); } 
             catch (e) { console.error("Error pausing audio:", e); showMessage("Error pausing playback.", 4000); }
        }
        function updatePlayPauseButton(playing, loading = false) {
            playPauseButton.classList.remove(...playButtonStateClasses, ...pauseButtonStateClasses, ...loadingButtonStateClasses, 'cursor-not-allowed');
            if (loading) { playPauseButton.textContent = "Loading..."; playPauseButton.classList.add(...loadingButtonStateClasses, 'cursor-not-allowed'); } 
            else if (playing) { playPauseButton.textContent = "Pause"; playPauseButton.classList.add(...pauseButtonStateClasses); } 
            else { playPauseButton.textContent = "Play"; playPauseButton.classList.add(...playButtonStateClasses); }
            playPauseButton.disabled = loading || playlist.length === 0 || (currentTrackIndex < 0 && playlist.length > 0 && !(audio && audio.buffer));
            if (!loading && playlist.length > 0 && currentTrackIndex >=0 && !(audio && audio.buffer)) { playPauseButton.disabled = false; }
        }
        function handleVolumeChange() { if (audio) audio.setVolume(volumeSlider.value / 100); }
        function handleSeekInput() { if (!audio || !audio.buffer || !hasAudioContextStarted || !isSeeking) return; currentTimeDisplay.textContent = formatTime(parseFloat(seekBar.value)); }
        function handleSeekChange() {
            if (!audio || !audio.buffer || !hasAudioContextStarted) return; isSeeking = false; const seekTime = parseFloat(seekBar.value); pauseTime = seekTime; currentTimeDisplay.textContent = formatTime(seekTime); 
            if (isPlaying) { try { audio.stop(); audio.offset = seekTime; audio.play(); startTime = audio.context.currentTime - seekTime; } catch (e) { console.error("Error seeking while playing:", e); showMessage("Error seeking.", 3000); resetUIOnError(); }} 
            else audio.offset = seekTime;
        }
        function handleSkipForward() {
            if (isLoadingTrack || playlist.length === 0) return; 
            let nextIndex = (currentTrackIndex + 1);
            if (currentTrackIndex === -1 && playlist.length > 0) {
                nextIndex = 0;
            } else if (nextIndex >= playlist.length && playlist.length > 0) {
                 showMessage("Reached end of playlist, looping to start.", 2000);
                 nextIndex = 0;
            }
            const playAfterSkip = isPlaying || (currentTrackIndex === -1); 
            if (isPlaying) { audio.stop(); isPlaying = false; }
            pauseTime = 0; 
            loadTrack(nextIndex, playAfterSkip); 
        }
        function handleSkipBack() {
            if (isLoadingTrack || playlist.length === 0) return;
            let prevIndex = currentTrackIndex - 1;
            if (currentTrackIndex === -1 && playlist.length > 0) {
                prevIndex = playlist.length - 1;
            } else if (prevIndex < 0 && playlist.length > 0) {
                showMessage("Reached start of playlist, looping to end.", 2000);
                prevIndex = playlist.length - 1;
            }
            const playAfterSkip = isPlaying || (currentTrackIndex === -1); 
             if (isPlaying) { audio.stop(); isPlaying = false; }
            pauseTime = 0; 
            loadTrack(prevIndex, playAfterSkip); 
        }
        function updateSkipButtonsState() {
            if (!skipBackButton || !skipForwardButton) return;
            const canSkip = playlist.length > 0 && !isLoadingTrack;
            skipBackButton.disabled = !canSkip;
            skipForwardButton.disabled = !canSkip;
        }

        // --- Animation Loop and Visualizer Updates ---
        function startAnimationLoop() { if (animationFrameId === null) animate(); } 
        function stopAnimationLoop() { if (animationFrameId !== null) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }}
        function pauseVisualizer() { if (isPlaying) pauseAudio();  } 
        function resumeVisualizer() { onWindowResize(); startAnimationLoop(); }
        function animate() {
            animationFrameId = requestAnimationFrame(animate);
            if (!isVisualizerInitialized || !renderer || !scene || !camera) return; 
            controls.update(); bodyElement.classList.toggle('dynamic-bg-transition', isPlaying);
            if (analyser && isPlaying && audio && audio.buffer) {
                if (!isSeeking) { const currentElapsedTime = audio.context.currentTime - startTime; const displayTime = Math.min(Math.max(0, currentElapsedTime), audio.buffer.duration); if (!isNaN(displayTime)) { seekBar.value = displayTime; updateRangeInputFill(seekBar, 'seek'); currentTimeDisplay.textContent = formatTime(displayTime); }}
                const data = analyser.getFrequencyData(); 
                switch (currentVisualizerType) { case VisualizerType.BARS: updateBarsVisualizer(data); break; case VisualizerType.CIRCLE: updateCircleVisualizer(data); break; case VisualizerType.WAVEFORM_LINES: updateWaveformLinesVisualizer(data); break; }
                const averageIntensity = analyser.getAverageFrequency(); updateBackgroundColor(averageIntensity);
                const now = Date.now(); if (now - lastDbUpdateTime > DB_UPDATE_INTERVAL) { updateDbDisplay(averageIntensity); lastDbUpdateTime = now; }
                const currentElapsedTimeCheck = audio.context.currentTime - startTime; 
                if (isPlaying && currentElapsedTimeCheck >= audio.buffer.duration - 0.05 && !audio.loop && !isLoadingTrack) { 
                     audio.stop(); isPlaying = false; pauseTime = 0; 
                     if (!isSeeking) { seekBar.value = audio.buffer.duration; updateRangeInputFill(seekBar, 'seek'); currentTimeDisplay.textContent = formatTime(audio.buffer.duration); }
                     renderPlaylist(); 
                     if (currentTrackIndex < playlist.length - 1) { showMessage(`Finished. Loading next...`, 1500); loadTrack(currentTrackIndex + 1, true); } 
                     else { showMessage("Playlist finished. Loop with skip buttons.", 4000); currentTrackIndex = -1; updatePlayPauseButton(false); updateSkipButtonsState(); fileNameDisplay.textContent = ""; resetTimelineUI(); renderPlaylist(); }
                 }
            } else if (isVisualizerInitialized) {
                 resetVisualizers(); 
                 if(dbValueDisplay && dbValueDisplay.textContent !== "-‚àû dB") { dbValueDisplay.textContent = "-‚àû dB"; dbValueDisplay.classList.remove('active'); lastDbUpdateTime = 0; if(dbTimeoutId) clearTimeout(dbTimeoutId); }
                 const targetBgColor = getComputedStyle(bodyElement).getPropertyValue('--bg-primary').trim(); if (bodyElement.style.backgroundColor !== targetBgColor) { bodyElement.style.transition = 'background-color 0.3s ease, color 0.3s ease'; bodyElement.style.backgroundColor = targetBgColor; }
            }
            renderer.render(scene, camera);
        }
        function updateDbDisplay(averageIntensity) { if (!dbValueDisplay) return; let dbValue; if (averageIntensity < 1) dbValue = "-‚àû"; else { const normalizedIntensity = Math.max(0, Math.log10(averageIntensity / 2.55 + 1) / Math.log10(101)); dbValue = mapRange(normalizedIntensity, 0, 1, DB_MIN, DB_MAX).toFixed(1); } dbValueDisplay.textContent = `${dbValue} dB`; dbValueDisplay.classList.add('active'); if (dbTimeoutId) clearTimeout(dbTimeoutId); dbTimeoutId = setTimeout(() => dbValueDisplay.classList.remove('active'), 500); }
        function updateBarsVisualizer(data) { const maxHeight = 80; currentVisualizerObjects.forEach((cube, i) => { if (!cube || !(cube instanceof THREE.Mesh) || i >= data.length) return; const value = data[i]; const height = (value / 255) * maxHeight + 0.1; const targetScaleY = Math.max(0.1, height); cube.scale.y += (targetScaleY - cube.scale.y) * 0.2; const hue = (i / NUM_BINS) * 0.7; const sat = 1.0; const light = Math.max(0.2, value / 255); const colors = cube.geometry.attributes.color; const color = new THREE.Color(); color.setHSL(hue, sat, light); for (let j = 0; j < colors.count; j++) colors.setXYZ(j, color.r, color.g, color.b); colors.needsUpdate = true; });}
        function updateCircleVisualizer(data) { const maxHeight = 60; currentVisualizerObjects.forEach((cube, i) => { if (!cube || !(cube instanceof THREE.Mesh) || i >= data.length) return; const value = data[i]; const height = (value / 255) * maxHeight + 0.1; const targetScaleY = Math.max(0.1, height); cube.scale.y += (targetScaleY - cube.scale.y) * 0.2; const hue = (i / NUM_BINS) * 1.0; const sat = 1.0; const light = Math.max(0.2, value / 255); const colors = cube.geometry.attributes.color; const color = new THREE.Color(); color.setHSL(hue, sat, light); for (let j = 0; j < colors.count; j++) colors.setXYZ(j, color.r, color.g, color.b); colors.needsUpdate = true;});}
        function updateWaveformLinesVisualizer(data) { if (!wfGeometry || !wfGeometry.attributes.position || wfFrequencyHistory.length === 0 || wfPreviousYValues.length === 0) return; for (let i = WF_NUM_LINES - 1; i > 0; i--) { if (wfFrequencyHistory[i] && wfFrequencyHistory[i-1]) wfFrequencyHistory[i].set(wfFrequencyHistory[i - 1]); if (wfPreviousYValues[i] && wfPreviousYValues[i-1]) wfPreviousYValues[i].set(wfPreviousYValues[i - 1]); } if (wfFrequencyHistory[0] && data.length === WF_LINE_LENGTH) wfFrequencyHistory[0].set(data); else if (data.length !== WF_LINE_LENGTH) { console.warn(`Data length mismatch`); return; } const positions = wfGeometry.attributes.position; const colors = wfGeometry.attributes.color; const color = new THREE.Color(); for (let lineIndex = 0; lineIndex < WF_NUM_LINES; lineIndex++) { if (!wfFrequencyHistory[lineIndex] || !wfPreviousYValues[lineIndex]) continue; for (let pointIndex = 0; pointIndex < WF_LINE_LENGTH; pointIndex++) { const vertexIndex = lineIndex * WF_LINE_LENGTH + pointIndex; const freqValue = wfFrequencyHistory[lineIndex][pointIndex]; const targetY = (freqValue / 255.0) * WF_VERTICAL_SCALE; const previousY = wfPreviousYValues[lineIndex][pointIndex]; const smoothedY = previousY * WF_SMOOTHING_FACTOR + targetY * (1 - WF_SMOOTHING_FACTOR); wfPreviousYValues[lineIndex][pointIndex] = smoothedY; positions.setY(vertexIndex, smoothedY); const hue = pointIndex / WF_LINE_LENGTH; const lightness = Math.max(0.1, Math.min(1.0, (freqValue / 255.0) * 1.5 * WF_COLOR_LIGHTNESS)); color.setHSL(hue, WF_COLOR_SATURATION, lightness); colors.setXYZ(vertexIndex, color.r, color.g, color.b); } } positions.needsUpdate = true; colors.needsUpdate = true;}
        function updateBackgroundColor(averageIntensity) { if (!isPlaying) return; const hue = 0.6 + (averageIntensity / 255) * 0.15; const sat = 0.6; const light = (currentTheme === 'light' ? 0.85 : 0.1) + (averageIntensity / 255) * (currentTheme === 'light' ? 0.10 : 0.10); bodyElement.style.backgroundColor = `hsl(${hue * 360}, ${sat * 100}%, ${light * 100}%)`;}
        function resetVisualizers() { let needsColorUpdate = false; let needsPosUpdate = false; currentVisualizerObjects.forEach(obj => { if (obj instanceof THREE.Mesh && obj.geometry && obj.scale) { const targetScaleY = 0.1; obj.scale.y += (targetScaleY - obj.scale.y) * WF_RESET_LERP_FACTOR; if (obj.geometry.attributes.color) { const colors = obj.geometry.attributes.color; const targetColor = new THREE.Color(currentTheme === 'light' ? 0xaaaaaa : 0x555555); const currentColor = new THREE.Color(); for (let j = 0; j < colors.count; j++) { currentColor.fromBufferAttribute(colors, j); currentColor.lerp(targetColor, WF_RESET_LERP_FACTOR); colors.setXYZ(j, currentColor.r, currentColor.g, currentColor.b); } colors.needsUpdate = true; }} else if (obj === wfLineSegments && wfGeometry && wfGeometry.attributes.position && wfGeometry.attributes.color && wfPreviousYValues.length > 0) { const positions = wfGeometry.attributes.position; const colors = wfGeometry.attributes.color; const targetColor = new THREE.Color(currentTheme === 'light' ? 0xcccccc : 0x444444); const currentColor = new THREE.Color(); for (let lineIndex = 0; lineIndex < WF_NUM_LINES; lineIndex++) { if (!wfPreviousYValues[lineIndex]) continue; for (let pointIndex = 0; pointIndex < WF_LINE_LENGTH; pointIndex++) { const vertexIndex = lineIndex * WF_LINE_LENGTH + pointIndex; const currentY = positions.getY(vertexIndex); const targetY = 0; const newY = currentY + (targetY - currentY) * WF_RESET_LERP_FACTOR; positions.setY(vertexIndex, newY); wfPreviousYValues[lineIndex][pointIndex] = newY; currentColor.fromBufferAttribute(colors, vertexIndex); currentColor.lerp(targetColor, WF_RESET_LERP_FACTOR); colors.setXYZ(vertexIndex, currentColor.r, currentColor.g, currentColor.b); } } needsPosUpdate = true; needsColorUpdate = true; }}); if (needsPosUpdate && wfGeometry && wfGeometry.attributes.position) wfGeometry.attributes.position.needsUpdate = true; if (needsColorUpdate && wfGeometry && wfGeometry.attributes.color) wfGeometry.attributes.color.needsUpdate = true;}
        function onWindowResize() { if (!isVisualizerInitialized || !camera || !renderer || !mainContentArea) return; const newWidth = mainContentArea.clientWidth; const newHeight = mainContentArea.clientHeight; camera.aspect = newWidth / newHeight; camera.updateProjectionMatrix(); renderer.setSize(newWidth, newHeight); }
        let messageTimeout = null; 
        function showMessage(text, duration = 3000) { if (messageTimeout) clearTimeout(messageTimeout); messageBox.textContent = text; messageBox.style.display = 'block'; if (duration > 0) { messageTimeout = setTimeout(() => { if (messageBox.textContent === text) messageBox.style.display = 'none'; messageTimeout = null; }, duration);}}
        function initAudioContextOnInteraction() { const startAudio = () => { if (audioContext && audioContext.state === 'suspended') { audioContext.resume().then(() => { hasAudioContextStarted = true; }).catch(e => console.error("Error resuming AudioContext:", e));} document.removeEventListener('click', startAudio); document.removeEventListener('touchstart', startAudio); document.removeEventListener('keydown', startAudio);}; document.addEventListener('click', startAudio); document.addEventListener('touchstart', startAudio); document.addEventListener('keydown', startAudio); showMessage("Click or tap the page to enable audio.", 5000); }
        function updateTimeDisplay() { if (currentTimeAboutDisplay && infoSidebar.classList.contains('open') && aboutPageContent.style.display !== 'none') { const now = new Date(); const timeString = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' }); currentTimeAboutDisplay.textContent = `${timeString}`;}}

        // --- Drag and Drop Handlers ---
        function handleDragStart(e) {
            if (e.target.classList.contains('playlist-item')) {
                draggedItem = e.target;
                e.dataTransfer.setData('text/plain', e.target.dataset.index); 
                e.dataTransfer.effectAllowed = 'move';
                setTimeout(() => { 
                    if (draggedItem) draggedItem.classList.add('dragging');
                }, 0);
            }
        }

        function handleDragOver(e) {
            e.preventDefault();
            const target = e.target.closest('.playlist-item');
            
            document.querySelectorAll('.drop-target-above, .drop-target-below').forEach(el => {
                el.classList.remove('drop-target-above', 'drop-target-below');
            });

            if (target && target !== draggedItem) {
                dragOverItem = target;
                const rect = target.getBoundingClientRect();
                const offsetY = e.clientY - rect.top;
                if (offsetY < rect.height / 2) {
                    target.classList.add('drop-target-above');
                } else {
                    target.classList.add('drop-target-below');
                }
                e.dataTransfer.dropEffect = 'move';
            } else {
                dragOverItem = null;
                e.dataTransfer.dropEffect = 'none';
            }
        }
        
        function handleDragLeave(e) {
            const target = e.target.closest('.playlist-item');
            if (target) {
                target.classList.remove('drop-target-above', 'drop-target-below');
            }
            if (!e.relatedTarget || !playlistItemsContainer.contains(e.relatedTarget)) {
                 if (dragOverItem) {
                    dragOverItem.classList.remove('drop-target-above', 'drop-target-below');
                 }
                dragOverItem = null;
            }
        }

        function handleDrop(e) {
            e.preventDefault();
            const fromIndex = parseInt(e.dataTransfer.getData('text/plain'));
            let targetElement = dragOverItem || e.target.closest('.playlist-item');

            document.querySelectorAll('.drop-target-above, .drop-target-below').forEach(el => {
                el.classList.remove('drop-target-above', 'drop-target-below');
            });
            if (draggedItem) draggedItem.classList.remove('dragging');


            if (isNaN(fromIndex) || !draggedItem) {
                draggedItem = null; dragOverItem = null; return;
            }
            
            let toIndex;
            if (targetElement && targetElement !== draggedItem) {
                toIndex = parseInt(targetElement.dataset.index);
                const rect = targetElement.getBoundingClientRect();
                const offsetY = e.clientY - rect.top;
                if (offsetY > rect.height / 2) {
                    toIndex++;
                }
            } else if (!targetElement && playlistItemsContainer.contains(e.target)) {
                toIndex = playlist.length;
            } else {
                draggedItem = null; dragOverItem = null; return;
            }

            const [movedItemData] = playlist.splice(fromIndex, 1);
            playlist.splice(toIndex > fromIndex ? toIndex -1 : toIndex, 0, movedItemData);

            if (currentTrackIndex === fromIndex) {
                currentTrackIndex = (toIndex > fromIndex) ? toIndex - 1 : toIndex;
            } else if (fromIndex < currentTrackIndex && (toIndex > fromIndex ? toIndex -1 : toIndex) >= currentTrackIndex) {
                currentTrackIndex--;
            } else if (fromIndex > currentTrackIndex && (toIndex > fromIndex ? toIndex -1 : toIndex) <= currentTrackIndex) {
                currentTrackIndex++;
            }
            
            renderPlaylist();
            updateSkipButtonsState(); 
            draggedItem = null;
            dragOverItem = null;
        }

        function handleDragEnd(e) {
            if (draggedItem) {
                draggedItem.classList.remove('dragging');
            }
            document.querySelectorAll('.drop-target-above, .drop-target-below').forEach(el => {
                el.classList.remove('drop-target-above', 'drop-target-below');
            });
            draggedItem = null;
            dragOverItem = null;
        }


        // --- Initial Setup ---
        if (window.AudioContext || window.webkitAudioContext) {
             if (!audioContext) { audioContext = THREE.AudioContext.getContext(); }
             if (audioContext.state === 'suspended') initAudioContextOnInteraction(); 
             else hasAudioContextStarted = true; 
        } else {
             console.error("Web Audio API not supported!");
             showMessage("Web Audio API is not supported by your browser. This visualizer cannot run.", 0); 
             if(playPauseButton) playPauseButton.disabled = true;
             if(skipBackButton) skipBackButton.disabled = true;
             if(skipForwardButton) skipForwardButton.disabled = true;
             if(audioFileInput) audioFileInput.disabled = true;
             if(fileUploadLabel) fileUploadLabel.style.opacity = '0.5';
        }

        if (!isVisualizerInitialized) {
            initVisualizer();
        }
        if(homePageContent) homePageContent.style.display = 'block'; 
        if(aboutPageContent) aboutPageContent.style.display = 'none';

        setInterval(updateTimeDisplay, 1000); 

    </script>
</body>
</html>
